\documentclass[10pt,a4paper,oneside]{scrbook}
\usepackage[utf8]{inputenc}     % Set UTF-8 input encoding
\usepackage[italian]{babel}     % Set up italian language
\usepackage{amsmath}            % Additional things
\usepackage{amsfonts}           % Additional things
\usepackage{amssymb}            % Additional symbols
\usepackage[dvipsnames]{xcolor} % Load colors
\usepackage{graphicx}           % Load graphics in document
\usepackage{frontespizio}       % For the first page
\usepackage{microtype}          % Additional symbols
\usepackage{textcomp}           % Additional symbols
\usepackage{hyperref}           % For links
\usepackage{tikz}               % Load TiKZ
\usepackage{pgfplots}           % Load graph tools
\usepackage{enumitem}           % For changing item bullets
\usepackage{minted}             % For source code listing
\usepackage{tcolorbox}          % For source code frames

% Make clickable links in document
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

% TiKZ settings
\usetikzlibrary{tikzmark}
\usetikzlibrary{calc}
\usetikzlibrary{shapes,snakes}

% Create useful environments for source code listing
\tcbuselibrary{skins,minted}
\newtcblisting{sourcecode}[1]{ % Generic source code environment, the argument is the language
    boxrule=1pt,
    listing only,
    listing engine=minted,
    minted language=#1,
    minted options={tabsize=2,escapeinside=??}
}
\newtcblisting{systemc}[1]{ % SystemC source code environment, the argument is the file title
    enhanced, 
    title={#1\strut}, 
    fonttitle=\bfseries, 
    attach boxed title to top left={xshift=3.2mm,yshift=-0.50mm}, 
    boxed title style={skin=enhancedfirst jigsaw,size=small,arc=1mm,bottom=-1mm}, 
    listing only,
    minted language=cpp,
    minted options={tabsize=2,escapeinside=??}
}

\begin{document}
\begin{frontespizio}
    \Universita{Verona}
    \Dipartimento{Informatica}
    \Corso{Ingegneria Informatica}
    \Annoaccademico{2018--2019}
    \NCandidati{Autori}
    \Candidato{Matteo Iervasi}
    \Candidato{Linda Sacchetto}
    \Candidato{Leonardo Testolin}
    \Titolo{Appunti di Progettazione di Sistemi Embedded}
\end{frontespizio}

\tableofcontents
\newpage

\chapter*{Prefazione}
Questa dispensa si basa sugli appunti di Linda Sacchetto e Leonardo Testolin durante il
corso di \textit{Progettazione di Sistemi Embedded} dell'anno accademico 2018/2019.
Nonostante sia stata revisionata in corso di scrittura, potrebbe contenere errori di vario tipo.
In tal caso potete segnalarli inviando una mail all'indirizzo \href{mailto:matteoiervasi@gmail.com}{matteoiervasi@gmail.com}.

\hspace*{\fill} Matteo Iervasi

\chapter{Introduzione}
Citando Wikipedia, un sistema embedded, nell'informatica e nell'elettronica,
identifica genericamente tutti quei sistemi elettronici di elaborazione digitale a microprocessore progettati
appositamente per una determinata applicazione (special purpose), ovvero non riprogrammabili dall'utente per altri scopi,
spesso con una piattaforma hardware ad hoc, integrati nel sistema che controllano ed in grado di gestirne tutte o
parte delle funzionalità richieste.

Storicamente, sono nati prima i sistemi embedded rispetto ai sistemi \textit{general purpose}, basti pensare ai
grandi calcolatori degli anni '40. Essi infatti erano costruiti per un utilizzo specifico, anche se in quanto a 
dimensioni non erano di certo ristretti.
Tuttavia il primo vero sistema embedded, in tutti i sensi, fu l'\textit{Apollo Guidance Computer}, che doveva
contenere una notevole potenza computazionale per il tempo in spazi ristrettissimi. La produzione di massa di 
sistemi embedded cominciò con l'\textit{Autonetics~D-17} nel 1961 e continua fino ai nostri giorni.

Non possiamo progettare i sistemi embedded come facciamo con i sistemi \textit{general purpose}, perché abbiamo
dei vincoli di progettazione e degli obiettivi differenti. Se ad esempio nei sistemi \textit{general purpose} la
ricerca si focalizza nel costruire processori sempre più veloci, nei sistemi embedded la CPU esiste solamente come
un modo per implementare algoritmi di controllo che comunica con sensori ed attuatori, e diventa invece più 
interessante trovare processori che usano sempre meno energia.

I vincoli principali ai quali bisogna attenersi durante la progettazione di un sistema embedded sono:
\begin{itemize}
    \item \textbf{Dimensione e peso}\\
          Si pensi ai dispositivi che devono poter essere tenuti in una mano
    \item \textbf{Energia}\\
          Molto spesso i dispositivi embedded devono funzionare con una batteria
    \item \textbf{Ambiente esterno ostile}\\
          Bisogna dover tenere conto di eventuali fluttuazioni di energia, interferenze radio, calore, acqua, ecc.
    \item \textbf{Sicurezza e operazioni \textit{real time}}\\
          Vi sono casi in cui è necessario che il sistema debba garantire sempre il funzionamento, oppure che 
          garantisca un tempo costante per ogni operazione
    \item \textbf{Costi contenuti}\\
          Oltre a tutto il resto, bisogna tenere i costi bassi altrimenti si rischia di non poter vendere il prodotto
\end{itemize}

\chapter{Modellazione dei sistemi embedded}
Nel momento in cui ci accingiamo a pensare a come si progetta un sistema embedded, salta subito alla mente un
problema, ovvero come faccio a verificarne il corretto funzionamento?
Quando progettiamo del software, abbiamo a disposizione una miriade di strumenti per assicurarci di tenere il numero
dei bug il più basso possibile: \textit{debugger}, \textit{unit testing}, \textit{analisi statica}, ecc.
In hardware invece non possiamo certamente metterci a rifare tutto ogni volta che sbagliamo, ricordiamoci che dobbiamo
tenere i costi bassi! Si pone quindi il problema della \textit{simulazione}, strumento fondamentale per la verifica
del nostro sistema. Spesso infatti l'architettura di riferimento è differente da quella del calcolatore che usiamo
per lo sviluppo (caso tipico: noi sviluppiamo su architettura X86 per un'architettura di destinazione ARM).

\smallskip
In generale, un sistema embedded è costituito dalle seguenti componenti:
\begin{itemize}
	\item \textbf{Piattaforma hardware}\\
    Oltre al microprocessore, vi sono una serie di altre componenti.
	\item \textbf{Componenti software}\\
    Il software è monolitico: quando accendo il sistema, si esegue in automatico.
    Possono anche esserci casi in cui è necessario caricare un intero sistema operativo, e nella maggioranza di essi si fa riferimento a Linux.
	\item \textbf{Componenti analogiche} (es. sensori e trasduttori)\\
    Naturalmente se il nostro sistema dovrà interagire con l'ambiente esterno dovremmo introdurre componenti analogiche.
\end{itemize}
Il trend attuale è di portare tutto ciò in un singolo chip (SoC - \textit{System on a Chip}), dove microprocessore,
memoria e altre componenti vengono montate su un singolo chip, collegate da un bus. Esempi di SoC moderni sono i
Qualcomm\textsuperscript{\tiny\textregistered} Snapdragon o i Samsung\textsuperscript{\tiny\textregistered} Exynos.
Esiste anche un'alternativa, dove le componenti invece di trovarsi in un unico chip si trovano in una singola
board (SoB - \textit{System on a Board}).

Queste due tecnologie hanno uno scopo in comune: indurre al riutilizzo di componenti già esistenti per
ridurre il più possibile il \textit{time to market} (figura \ref{img:time-to-market}), ovvero il tempo che trascorre
dall'inizio della progettazione all'immissione nel mercato. Più questo tempo è lungo, meno probabilità si ha di riuscire a vendere
il prodotto in quantità tale da coprire i costi di sviluppo.
Per questo motivo non si può minimamente pensare di sviluppare un sistema embedded partendo da zero, in quanto il tempo di sviluppo
sarebbe improponibile.

\begin{figure}
	\centering
	\caption{Rappresentazione del rapporto costo produzione - guadagno}
	\label{img:time-to-market}
	\begin{tikzpicture}
		\centering
		\begin{axis}[
			axis lines=left,
			width=\textwidth,
			height=200pt,
            xmin=0,
			xlabel=Tempo,
			ylabel=Costo,
            yticklabels={,,},
            xticklabels={,,},
		]
		\addplot[
			domain=0:7,
			samples=150,
			color=blue,
			line width=1.25pt,
		]{5*ln(x-1/2)+3};
        \addlegendentry{Costo di produzione}
        \addplot[
            domain=1.25:7,
   			samples=150,
   			color=red,
   			line width=1.25pt,
        ]{20/ln(x)-20};
        \addlegendentry{Prezzo di vendita}
		\end{axis}
        \draw [dashed] (0.9,0) node [below]{$t_0$};
        \draw [dashed] (2,0) node [below]{$t_m$} -- (2,5.5);
        \draw [dashed] (3.6,0) -- (3.6,1.4);
        \draw [<->](2,0.70) -- (3.6,0.70) node [below, midway] {$\Delta_t$};
        \draw [->] (0.9,-0.45) -- (1,-1) node [below] {Inizio realizzazione oggetto};
        \draw [->] (2,-0.45) -- (4,-1.5) node [below] {Inizio vendita oggetto};
	\end{tikzpicture}
\end{figure}

\section{Co-design di sistemi embedded}
Viste le ristrettezze imposte sui tempi dal mercato, è necessario ricorrere al co-design di hardware e software.
Si parte quindi con una descrizione generale del sistema, magari aiutandosi con un prototipo, dopodiché fatte le verifiche su di esso si procede con la separazione di
hardware e software, ricordandosi che è necessario ‘‘riciclare’’ il più possibile le parti già esistenti, si comincia lo sviluppo o l'eventuale adattamento.
Durante la progettazione della parte hardware, si può decidere di affiancare l'eventuale processore da un co-processore, che svolge un compito
specifico a seconda di cosa stiamo progettando. Il co-processore può essere anche una GPU.

Le tecnologie più usate per la progettazione di hardware sono:
\begin{itemize}
	\item Microcontrollore standard o microprocessore
	\item ASIC (con o senza co-processore a seconda dei casi)
	\item FPGA
\end{itemize}
mentre per il software si possono utilizzare diversi linguaggi di programmazione (generalmente però si scelgono C/C++).

Naturalmente ci serve uno strumento per la verifica del nostro sistema, ci serve quindi co-simulare hardware e software.
Si può fare su diversi livelli, ognuno con i suoi pregi e i suoi difetti.
\begin{itemize}
	\item \textbf{Gate level}\\
	Viene simulato il tutto a livello di porte logiche, ovvero il più basso livello
	possibile. Questa è la simulazione più lenta in assoluto.
	\item \textbf{RTL (Register Transfer Level)}
	La rappresentazione in questo caso è vista come un flusso di informazioni che
	percorre il sistema, i cui risultati vengono salvati nei registri. Anche questa
	simulazione è lenta poiché molto vicina all'hardware.
	Essa può essere \textit{cycle accurate}, nella quale l'unità minima di elaborazione è il ciclo
	di clock dove è considerato come importante quello che avviene all'inizio e alla fine di esso,
	oppure può essere \textit{instruction accurate}, nella quale l'unità minima diventa la singola istruzione.
	\item \textbf{Behavioural}\\
	Questa rappresentazione descrive le funzionalità facendo una stima dei cicli di clock che impiega
	\item \textbf{Transactional}\\
	In questo caso non ho nemmeno il dettaglio della funzionalità, ma vado solamente a descrivere
	le interazioni tra i singoli moduli hardware. La simulazione in questa modalità è rapida.
\end{itemize}

Ogni livello di descrizione ha dei linguaggi più adatti di altri nonostante siano stati fatti diversi
sforzi di crearne uno adatto a tutti.
A livello RT, quelli più diffusi sono \textit{VHDL} e \textit{Verilog}.
\textit{SystemC}, nonostante sia in grado di scrivere più o meno bene a livello RT, mostra la sua
potenza espressiva agli altri livelli.

\section{Hardware description languages}
Gli \textit{Hardware Description Languages} (HDL) sono nati per risolvere una serie di problemi.
Prima di essi l'hardware veniva progettato a mano e senza alcuna procedura standardizzata. Questo
approccio però è prono ad errori e soprattutto incompatibile con le tempistiche richieste al giorno d'oggi.
Quando progetto del software mi basta pensare all'algoritmo astratto e codificarlo in un preciso linguaggio
di programmazione. Può anche succedere che il linguaggio che utilizzo sia multipiattaforma, per cui non mi dovrò
minimamente preoccupare di dove e come verrà eseguito, poiché so che a prescindere dall'architettura sul quale
verrà eseguito darà sempre lo stesso risultato.
Quando progettiamo hardware invece non possiamo permetterci questo lusso in quanto l'architettura semplicemente
non c'è, siamo noi a costruirla.

Prendiamo in esempio un programma scritto in linguaggio C e osserviamo le assunzioni che facciamo senza nemmeno pensare.\\
\begin{sourcecode}{c}
#include <stdio.h>

int gcd(int xi, int yi){
   	int x, y, temp;
   	
   	x = xi;
   	y = yi;
   	while(x > 0){
   		if(x <= y){
   			temp = y;
   			y = x;
   			x = temp;
   		}
   		x = x - y;
   	}
   	return(y);
}

int main(int argc, char *argv[]){
   	int xi, yi, ou;
    
    scanf("%d %d", &xi, &yi);
    ou = gcd(xi, yi);
    printf("%d\n", ou);
    
    return 0;
}
\end{sourcecode}
I requisiti hardware per poter eseguire questo programma sono:
\begin{itemize}
    \item \textbf{Input/Output}\\
    \textit{SW}: \texttt{printf}, \texttt{scanf}, ...\\
    \textit{HW}: interfacce di I/O
    \item \textbf{Temporizzazione}\\
    \textit{SW}: istruzioni vengono eseguite alla velocità del ciclo di clock\\
    \textit{HW}: devono essere definiti uno o più segnali di clock (e le istruzioni possono impiegare diversi cicli di clock)
    \item \textbf{Dimensioni variabili}\\
    \textit{SW}: dimensioni implicite sono nascoste\\
    \textit{HW}: devo tenere conto delle dimensioni, in quanto sto creando qualcosa di fisico che poi corrisponderà alla variabile
    \item \textbf{Operazioni}\\
    \textit{SW}: esistono librerie per ogni tipo di operazioni\\
    \textit{HW}: difficili dato che devo fare un circuito apposito. Se poi vogliamo anche i numeri in virgola mobile, il circuito aumenta molto in complessità
    \item \textbf{Identificazione elementi di memoria}\\
    \textit{SW}: non guardo se una variabile va nei registri o nella RAM, la uso e basta\\
    \textit{HW}: devo sapere che spazio andrà a occupare, c'è una bella differenza tra registro e memoria
    \item \textbf{Sincronizzazione moduli}\\
    \textit{SW}: spesso lavoro in maniera sequenziale\\
    \textit{HW}: per com'è strutturato, l'hardware lavora tantissimo in parallelo        
\end{itemize}
Quando scriviamo l'algoritmo software facciamo quindi molte assunzioni, del tutto legittime, ma che non possiamo di certo dare per 
scontato quando invece progettiamo un modulo hardware.

\noindent
La prima cosa di cui bisogna preoccuparsi è definire le porte d'ingresso e di uscita. Una volta completata
l'identificazione delle porte, bisogna individuare la modalità con cui andremo a progettare il modulo,
che nel nostro caso sarà una FSMD, ovvero una macchina a stati finiti combinata con un datapath. 
Nella definizione della FSM e del DP, bisogna tenere conto degli eventuali vincoli: se ad esempio mi interessa un circuito veloce posso permettermi un DP più grande, mentre se voglio che il mio circuito occupi il minor spazio possibile dovrò allargare la FSM.
Riportiamo di seguito un possibile diagramma del modulo \texttt{gcd}.
\begin{figure}[h]
    \centering
    \begin{tikzpicture}
        \draw [->] (0,2) node[above]{XI} -- (1,2);
        \draw [->] (0,1) node[above]{YI} -- (1,1);
        \draw [<-] (2,3) -- (2,4) node[left]{CLOCK};
        \draw [<-] (4,3) -- (4,4) node[left]{RESET};
    
        \draw [fill=SkyBlue] (1,0) rectangle (5,3) node[pos=.5] {GCD};
        
        \draw [->] (5,1.5) -- (6,1.5) node [above] {OUT};
    \end{tikzpicture}
    \label{img:gcd_scheme}
    \caption{Schema di un modulo GCD}
\end{figure}

\pagebreak\noindent
Questa è una possibile implementazione in VHDL del modulo GCD, descritta dal punto di vista ingressi-uscite:
\begin{sourcecode}{VHDL}
ENTITY gcd IS
    PORT (
        clock : IN bit; ?\tikzmark{gcd_input1}?
        reset : IN bit; ?\tikzmark{gcd_input2}?
        xi : IN unsigned (size-1 DOWNTO 0); ?\tikzmark{gcd_input3}?
        yi : IN unsigned (size-1 DOWNTO 0); ?\tikzmark{gcd_input4}?
        out : OUT unsigned (si?\tikzmark{gcd_varsize}?ze-1 DOWNTO 0) ?\tikzmark{gcd_output}?
    );
END gcd;
\end{sourcecode}
\begin{tikzpicture}[remember picture]
    \draw[overlay, ->] ($(pic cs:gcd_input1)+(0,0.1)$) -- ($(pic cs:gcd_input1)+(5,-0.3)$) node [right]{porte di input};
    \draw[overlay, ->] ($(pic cs:gcd_input2)+(0,0.1)$) -- ($(pic cs:gcd_input1)+(5,-0.3)$);
    \draw[overlay, ->] ($(pic cs:gcd_input3)+(0,0.1)$) -- ($(pic cs:gcd_input1)+(5,-0.4)$);
    \draw[overlay, ->] ($(pic cs:gcd_input4)+(0,0.1)$) -- ($(pic cs:gcd_input1)+(5,-0.4)$);
    \draw[overlay, ->] ($(pic cs:gcd_output)+(0,0.1)$) -- ($(pic cs:gcd_output)+(1,0.1)$) node [right]{porta di output};
    \draw[overlay, ->] ($(pic cs:gcd_varsize)+(0,-0.05)$) -- ($(pic cs:gcd_varsize)+(0,-0.5)$) node [below]{dimensione variabile};
\end{tikzpicture}
mentre questa è la descrizione comportamentale del modulo hardware:
\begin{sourcecode}{VHDL}
ARCHITECTURE behavioral OF gcd IS
BEGIN
    PROCESS
        VARIABLE x, y, temp : unsigned (size-1 DOWNTO 0);
    BEGIN
    WAIT UNTIL clock = '1'; 
    x := xi;
    y := yi;
    WHILE (x > 0) LOOP
        IF (x <= y) THEN
            temp := y;
            y := x;
            x := temp;
        END IF;
        x := x - y;
    END LOOP;
    ou <= y;
    END PROCESS;
END behavioral;
\end{sourcecode}

\chapter{SystemC}
SystemC è un insieme di classi e macro del linguaggio C++ che forniscono un ambiente di simulazione \textit{event-driven}.
Queste classi permettono al progettista di simulare processi concorrenti,  che possono anche comunicare in un ambiente
real-time simulato, utilizzando segnali di qualsiasi tipo forniti da C++/SystemC o dall'utente.
Sebbene sia per certi versi simile a linguaggi come VHDL o Verilog, è più corretto definire SystemC un linguaggio di
modellazione di sistemi.
Lo standard è definito dalla \textit{Open SystemC Initiative} (OSCI), ora \textit{Accellera}, ed è stato
approvato dall'IEEE. Le caratteristiche salienti del SystemC sono:
\begin{itemize}
    \item \textbf{Concorrenza}\\
    Processi sincroni e asincroni
    \item \textbf{Comunicazione}\\
    IPC tramite segnali e canali
    \item \textbf{Nozione di tempo}\\
    Possibilità di avere cicli di clock multipli con fasi arbitrarie
    \item \textbf{Reattività}\\
    Possibilità di attesa su eventi
    \item \textbf{Tipi di dato hardware}\\
    Vettori di bit, interi a precisione arbitraria, ecc.
    \item \textbf{Simulazione}\\
    Kernel di simulazione incluso nella libreria
    \item \textbf{Debugging}\\
    Possibilità di utilizzare i debugger disponibili per C/C++ come GNU GDB
\end{itemize}
\begin{figure}
    \centering
    \begin{tikzpicture}        
        \node[draw, align=center](rtlevel) at (0,0) {SystemC Model\\RT Level};
        \node[draw, ellipse, align=center](refinement) at (0,1.2) {Refinement};
        \node[draw, ellipse, align=center](simulation) at (0,2.2) {Simulation};
        \node[draw, align=center](systemlevel) at (0,3.4) {SystemC Model\\System Level};
        
        \node[draw, align=center, fill=CornflowerBlue](fsmd) at (4,0) {FSMD Logic\\description};
        \node[draw, ellipse, align=center, fill=CornflowerBlue](synthesis) at (4,1.2) {Synthesis};
        \node[draw, align=center, fill=CornflowerBlue](vhdl) at (4,2.4) {VHDL/Verilog};
        
        \draw[->, thick] (systemlevel) -- (simulation);
        \draw[->, thick] (simulation) -- (refinement);
        \draw[->, thick] (refinement) -- (rtlevel);
        \draw[->, thick] (rtlevel.west) -- ++(-20pt,0pt) |- ($(simulation.west)+(0,-2pt)$);
        \draw[->, thick] ($(simulation.west)+(0,2pt)$) -- ++(-20pt,0pt) |- (systemlevel.west);
        
        \draw[->, thick] (vhdl) -- (synthesis);
        \draw[->, thick] (synthesis) -- (fsmd);
        \draw[->, thick] (rtlevel.south) -- ++(0pt,-10pt) -- ++(2,0) -- ++(0,4) node[midway] (middle){}  -- ++(2,0) node[above] {Automatic translation}-- (vhdl.north);
        \draw[->, thick, dashed] (middle) -- (synthesis.west);
    \end{tikzpicture}
    \label{img:systemc_design_flow}
    \caption{SystemC design flow}
\end{figure}    
Quando si progettano sistemi complessi, viene naturale dividere il progetto in sotto parti, che chiamiamo \textit{moduli},
ognuno dei quali svolge una specifica funzione e comunica con altri. In SystemC i moduli sono rappresentati nientemeno che 
da delle classi C++ e si specificano con la keyword \textit{\texttt{SC\_MODULE}}.
Un modulo contiene la definizione delle porte di input e di output, i segnali interni con la loro eventuale inizializzazione
e i sottomoduli, che sono rappresentati nella loro forma minima dalle funzioni.
Inoltre ogni modulo contiene un metodo costruttore, identificato dalla macro \textit{\texttt{SC\_CTOR}}, che contiene
la dichiarazione di tutti i processi contenuti nel modulo e la sensitivity list associata a tali metodi, che specifica
i segnali ai quali ciascun metodo deve reagire.

I processi che vengono dichiarati all'interno di ogni modulo possono essere di tre tipi:
\begin{itemize}
    \item \textbf{Metodi}\\
    Sono dei processi che quando vengono attivati ogni volta che arriva uno dei segnali espressi nella sensitivity list.
    Si identificano con la keyword \textit{\texttt{SC\_METHOD}}.
    \item \textbf{Thread}\\
    Sono dei processi che possono essere attivati o sospesi, mediante la funzione \textbf{\texttt{wait()}}.
    A differenza dei metodi, possono essere eseguiti una volta sola durante la simulazione.
    Si identificano con la keyword \textit{\texttt{SC\_THREAD}}.
    \item \textbf{Clocked threads}\\
    Sono dei processi sensibili al segnale di clock. Sono stati dichiarati obsoleti.
\end{itemize}
La simulazione in SystemC è gestita dal kernel, che gestisce lo scheduling nel seguente modo:
\begin{itemize}[label={$\Rightarrow$}]
    \item Tutti i segnali di clock vengono aggiornati
    \item Tutti i processi sensibili ad esso vengono attivati
    \item Si aumenta il tempo di simulazione di 1
\end{itemize}
Il segnale di clock viene generato normalmente da un thread che definisce anche il periodo del segnale.
Oltre a poter eseguire una simulazione \textit{event-driven}, è anche possibile farne una \textit{cycle accurate}.
La differenza sta nella velocità e nella precisione della simulazione, infatti in quella \textit{cycle accurate} si
osservano i cambiamenti ad ogni cambio di fronte, senza però preoccuparsi di osservare i cambiamenti che avvengono
durante il ciclo.
\section{SystemC RTL}
Come detto precedentemente, in SystemC si possono descrivere sistemi hardware e software a diversi livelli di astrazione,
rendendo possibile il co-design. In particolare, si può descrivere a livello RT o TLM.
Nel \textit{Register Transfer Level} si può descrivere il funzionamento di un circuito digitale in termini di segnali,
registri e operazioni logiche.

SystemC mette a disposizione dei tipi predefiniti, utili ad identificare: 
\begin{itemize}
    \item \texttt{sc\_int<n>} e \texttt{sc\_uint<n>}\\
    Con questi rappresento un valore intero con o senza segno.
    \item \texttt{sc\_bigint<n>} e \texttt{sc\_biguint<n>}\\
    Con questi rappresento un valore intero molto grande, con o senza segno.
    \item \texttt{sc\_bit}\\
    Rappresento un singolo bit di informazione.
    \item \texttt{sc\_logic}\\
    Tipo a 4 valori: $0$, $1$, \texttt{unknown} e \texttt{don't care}.
    \item \texttt{sc\_bv<n>} e \texttt{sc\_lv<n>}\\
    Vettore di bit e vettore di valori logici.
    \item \texttt{sc\_fixed} e \texttt{sc\_ufixed}\\
    Servono per rappresentare valori in virgola fissa.
    \item \texttt{sc\_fix} e \texttt{sc\_ufix}\\
    Alias per \texttt{sc\_fixed} e \texttt{sc\_ufixed}.
\end{itemize}
Per quanto riguarda le porte invece vi sono:
\begin{itemize}
    \item \texttt{sc\_in<PORT\_TYPE>}\\
    Identifica una porta di input
    \item \texttt{sc\_out<PORT\_TYPE>}\\
    Identifica una porta di output
    \item \texttt{sc\_signal<PORT\_TYPE>}\\
    Codifica un segnale utile per collegare le porte (che nella sintesi molto probabilmente diventerà un filo)
\end{itemize}

Analizziamo la codifica RT tramite un esempio, nel quale implementiamo uno shifter a 8 bit.
\begin{systemc}{shifter.h}
#include <systemc.h>
#define N 8

SC_MODULE(shifter) {  ?\tikzmark{shifter_module}?
  sc_in<bool> ds; ?\tikzmark{shifter_input1}?
  sc_in<sc_bv<N>> a;
  sc_in<bool> i0; ?\tikzmark{shifter_input2}?
  sc_out<sc_bv<N>> o; ?\tikzmark{shifter_output}?

  void shift(); ?\tikzmark{shifter_method}?

  SC_CTOR(shifter) {
    SC_METHOD(shift);
    sensitive << ds << a << i0; ?\tikzmark{shifter_sensitivity}?
  }
};
\end{systemc}
\begin{tikzpicture}[remember picture]
    \draw[overlay, ->] ($(pic cs:shifter_module)+(0,0.1)$) -- ($(pic cs:shifter_module)+(1,0.3)$) node [right]{dichiarazione del modulo};
    \draw[overlay, decorate, decoration={brace,amplitude=5pt}] ($(pic cs:shifter_input1)+(1,0.2)$) -- ($(pic cs:shifter_input2)+(1,-0.2)$) node [black, midway, xshift=1.3cm]{porte di input};
    \draw[overlay, ->] ($(pic cs:shifter_output)+(0,-0.1)$) -- ($(pic cs:shifter_output)+(0.4,-0.3)$) node [right]{porta di output};
    \draw[overlay, ->] ($(pic cs:shifter_method)+(0,0.1)$) -- ($(pic cs:shifter_method)+(0.4,0.1)$) node [right]{dichiarazione metodo interno};
    \draw[overlay, ->] ($(pic cs:shifter_sensitivity)+(0,0.1)$) -- ($(pic cs:shifter_sensitivity)+(0.4,0.1)$) node [right]{dichiarazione sensitivity list};
\end{tikzpicture}
\begin{systemc}{shifter.cpp}
#include "shifter.h"

void shifter::shift() {
  bool ds1;
  bool i01;
  sc_bv<N> a1;
  sc_bv<N> c1;

  i01 = i0.read();
  ds1 = ds.read();
  a1 = a.read();

  if (ds1 == 1) {
    c1.range(N - 2, 0) = a1.range(N - 1, 1);
    c1[N - 1] = i01;
  } else {
    c1.range(N - 1, 1) = a1.range(N - 2, 0);
    c1[0] = i01;
  }
  o.write(c1);
}
\end{systemc}
Nell'header si definisce il nome del modulo con la macro \texttt{SC\_MODULE}, le sue porte di input e di output (con tipo di dato e ampiezza in bit quando
richiesto), i metodi che implementano il comportamento del modulo e la \textit{sensitivity list}, ovvero la lista dei segnali a cui il modulo è sensibile.
Tramite le macro \texttt{SC\_METHOD}, \texttt{SC\_THREAD} e \texttt{SC\_CTHREAD} identifico rispettivamente i metodi, i thread e i clocked thread (deprecati).

\section{SystemC TLM}
Anche se in SystemC è possibile progettare hardware a livello RT, quello che lo ha reso interessante 
rispetto a VHDL/Verilog è la capacità di poter fare \textit{platform based design}.
La progettazione platform based consiste nella creazione di un'architettura basata su microprocessore che può essere estesa rapidamente
per un ampio range di applicazioni in tempi ridotti.
In TLM si descrive il sistema a livello comportamentale, in cui non si sa esattamente cosa succede a ogni ciclo
di clock. Ci si focalizza sulle transizioni tra le varie componenti, che nel concreto diventeranno delle interfacce.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth]{"img/platform based design"}
    \caption{Visualizzazione della progettazione \textit{platform based}}
    \label{fig:platform-based-design}
\end{figure}

Date le specifiche, che possono essere in un linguaggio ad alto livello come UML, MATLAB o C/C++, si codificano i
vari moduli e le interazioni fra di essi e si passa al profiling, in cui si decide cosa diventa software e cosa 
diventa hardware. È pratica comune riutilizzare componenti già codificate da altri, tanto che esistono portali dedicati
all'IP re-use (\textit{Intellectual Properties re-use}).
I vantaggi principali offerti dalla progettazione TLM sono la velocità di simulazione (fino a 1000 volte più veloce 
rispetto a RTL), la semplificazione del design e una riduzione drastica dei tempi di sviluppo.

Alla base del TLM vi è il concetto di transazione, che permette il trasferimento di dati da un modulo all'altro.
La comunicazione avviene tramite la chiamata di una primitiva del ricevente (che chiameremo \textit{target})
da parte del mittente (\textit{initiator}), alla quale viene agganciato un \textit{payload}, che contiene sia
informazioni utili sia di controllo.
\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth]{"img/initiator target"}
    \caption{Schema forward/backward path}
    \label{fig:forward-backward-path}
\end{figure}

\noindent
SystemC ha definito due standard diversi di TLM. Nello standard 1.0 venivano proposti 3 diversi livelli di astrazione, ovvero
\begin{itemize}
    \item Program View (PV)
    \item Program View with Time (PVT)
    \item Cycle Accurate (CA)
\end{itemize}
tuttavia nello standard 2.0 sono stati abbandonati per concentrarsi invece nella relazione tra dati e tempo.
Sono stati definiti quindi 3 modi livelli di accuratezza:
\begin{itemize}
    \item \textbf{Untimed}
    \subitem Interfacce bloccanti
    \subitem Punti di sincronizzazione predefiniti
    \item \textbf{Loosely timed}
    \subitem Interfacce bloccanti
    \subitem Due punti di sincronizzazione (invocazione e ritorno)
    \item \textbf{Approximately timed}
    \subitem Interfacce non bloccanti
    \subitem Annotazione del tempo con fasi multiple durante la transazione
\end{itemize}
Le interfacce bloccanti, supportate dalle descrizioni UT e LT utilizzano solamente il forward path.
L'initiator chiama il metodo \texttt{b\_transport} del target, che ritorna il valore nel payload stesso.
Lo stile \textit{untimed} e il \textit{loosely timed} sono sufficientemente dettagliati per poter eseguire il boot 
di sistema operativo sull'architettura simulata. Permettono anche meccanismi complessi come
il \textit{temporal decoupling}, nel quale due processi che lavorano in contemporaneo a volte possono andare per conto proprio oltre il tempo attuale
della simulazione, per poi arrivare al punto di sincronizzazione. Con questo stile posso solamente fare una stima del tempo trascorso con un minimo e un massimo.

Nello stile \textit{approximately timed} le transazioni vengono divise in più fasi. Il protocollo base usa 4 fasi (per questo lo stile viene chiamato AT4):
\begin{itemize}
    \item Inizio richiesta (\texttt{BEGIN\_REQ})
    \item Fine richiesta (\texttt{END\_REQ})
    \item Inizio risposta (\texttt{BEGIN\_RESP})
    \item Fine risposta (\texttt{END\_RESP})
\end{itemize}
La sincronizzazione avviene più frequentemente quindi di LT, per questo il tempo di simulazione è più lungo, ma ottengo una stima del tempo molto accurata.

%TODO: migliorare TLM

\section{SystemC AMS}


\chapter{VHDL}
VHDL è un linguaggio standard per la progettazione di hardware digitale. Può essere usato a diversi livelli di astrazione, che vanno da una descrizione algoritmica fino a quella di livello gate ma è lo standard per il livello RT. La progettazione può essere eseguita a diversi livelli che possono poi essere collegati tra loro. Il design può essere gerarchico, quindi con una struttura complessa, ed è possibile approcciare con un flusso di progettazione di tipo top-down oppure Bottom-up.
\begin{itemize}
    \item Top-Down \\
    Parto da una descrizione generale e vado a specializzare poi i singoli blocchi.
    \item Bottom-Up\\
    Modello blocchi specifici e poi vado a collegarli tra loro.
\end{itemize}
Permette di specificare controllore e datapath. Nato dagli anni '80 figlio del linguaggio ad oggetti ADA, nel 1992 diventa standard IEEE.\\
Offre la possibilità di scrivere hardware:
\begin{itemize}
    \item Combinatorio
    \item Sequenziale:
    \begin{itemize}
        \item Sincrono: con clock esplicito, identificato da template.
        \item Asincrono: modellazione basata su eventi, non sintetizzabile in maniera automatica.
    \end{itemize}
\end{itemize}

\section{Tempo}
In VHDL abbiamo una simulazione con tempistiche accurate. A livello RT il tempo non è definito ma dettato dagli eventi, mentre a livelli più astratti sono io a definirlo esplicitamente
\section{Utilizzi di VHDL}
VHDL è nato per simulare, modellare, documentare, sintetizzare, verificare e testare l'hardware
\begin{itemize}
    \item Modellazione: specifico un design complesso utilizzando un approccio top-down, in particolare un approccio incrementale.\\
    Con incrementale intendo la possibilità di suddividere il mio hardware in vari moduli e realizzarli con blocchi fittizi. Successivamente vado ad implementare i blocchi uno alla volta andando a testare il loro funzionamento ed eventualmente modificandoli. Questo mi evita la scrittura di grandi porzioni di codice senza eseguirlo e verificarlo.
    \item Simulazione: verifico il comportamento del mio design. Ogni volta che la mia simulazione porta ad un risultato desiderato, vado a raffinare i miei moduli e simulare nuovamente.
    \item Sintesi: dopo aver raffinato la mia descrizione ad un livello di dettaglio tale da poter produrre hardware in modo automatico implemento in hardware il mio progetto.
    \item Prova formale: verifico che la mia descrizione combaci con specifiche ad alto livello.
    \item Verifica: controllo la consistenza interna di sue passaggi consecutivi andando a provare una corretta implementazione.
    \item Validazione: controllo che il mio sistema sia una soluzione soddisfacente ad un problema reale.
    \item Documentazione: VHDL può essere utilizzato per documentare un progetto. La documentazione è usata come mezzo di comunicazione tra:
    \begin{itemize}
        \item uomo-tool
        \item tool-tool
        \item uomo-uomo
    \end{itemize}
\end{itemize}
\section{Sintassi}
Tipi:\\
\begin{itemize}
    \item Real
    \item Integer
    \begin{itemize}
        \item signed
        \item unsigned
    \end{itemize}
    \item Boolean
    \item Character
    \item Bit
    \item Time
    \item std\_logic
    \begin{itemize}
        \item U: non inizializzato.
        \item X
        \item 0
        \item 1
        \item Z
        \item W: sconosciuto debole.
        \item L: zero debole.
        \item H: uno debole.
        \item -: don't care.
    \end{itemize}
\end{itemize}
Quando non inizializzo una variabile o un segnale prende o il valore minimo o il più a sinistra a seconda del tipo. In std\_logic prende U.
Cose che puoi dichiarare:\\
\begin{itemize}
    \item Costanti:\\
    \textbf{COSTANT nome:tipo:= exp}
    \item Segnali:\\
    collega tra loro design entities, sono nella sensitivity list dei processi(quindi a d ogni cambiamento scatta il processo), possono essere dichiarati solamente tra \textbf{ARCHITECTURE} e \textbf{BEGIN}.\\
    dichiarazione: \textbf{SIGNAL} nome \textbf{:} tipo \textbf{:=} exp, assegnamento: S1 \textbf{\textless=} exp
    \item Entity:\\
    E' l'interfaccia composta da entity declaration e architecture body. Nella declaration vado ad indicare le porte di ingresso e uscita mentre nel body descrivo l'implementazione basandomi sul mix dei 3 stili: behavioral, data flow, structural. Equivalente a SC\_MODULE in SyetemC.\\
    dichairazione:\\ %TODO -> non sono in grado di scriverlo.
    ENTITY name IS\\
    BEGIN\\
        GENERIC(a:bit:='0', b:bit:='1');\\
        PORT(i0, i1, i2: IN BIT(32 DOWNTO 0); o0, o1: OUT BIT(32 DOWNTO 0));\\
    END nome\\
    \\
    body:\\
    ARCHITECTURE nome\_arch OF nome IS\\
        signed s:std\_logic\_vector(8 DOWNTO 0);\\
    BEGIN\\
        PROCESS(s)\\
            variable a:bit:='1';\\
        BEGIN\\
            .\\
            .\\
            .\\
        END PROCESS\\
    END nome\_arch
\end{itemize}
\chapter{Esercizi}
Si consideri il seguente spezzone di codice SystemC comportamentale, che si vuole raffinare a livello RT, garantendo
la latenza minima e il minimo numero di componenti, sotto il vincolo di utilizzare un solo sommatore.
\begin{sourcecode}{C++}
    // input ports reading
    a = a_in.read();
    b = b_in.read();
    c = c_in.read();
    while(a < b){
        d = a + a * (b + 1);
        e = e + c * a;
        f = c * a + d;
        if(e < f)
            f_out.write(a + b);
        else
            f_out.write(a * b);
        a = a + b;
    }
\end{sourcecode}
\begin{itemize}
    \item Si assuma che tutte le variabili siano numeri interi con segno a $N$ bit e che tutte le variabili esplicitamente
    lette o scritte siano porte di ingresso o uscita del modulo.
    \item Si identifichino eventuali ottimizzazioni del codice dato.
    \item Si identifichi lo scheduling a latenza minima che utilizza il minimo numero di operatori.
    \item Si descriva in VHDL il risultato dello scheduling mediante una EFSM composta da due processi.
    \item Si identifichi una possibile allocazione dei registri che tenda a minimizzarne il numero.
    \item Si descriva in VHDL data-flow la parte del \textit{data-path} del circuito identificatore che effettua
    il solo calcolo di aggiornamento della variabile \texttt{f}.
\end{itemize}
Innanzitutto cerchiamo di ottimizzare. La lettura è apposto così, poi abbiamo uno spezzone ottimizzabile:
\begin{sourcecode}{C++}
        d = a + a * (b + 1);
        e = e + c * a;
        f = c * a + d;
\end{sourcecode}
La prima riga è equivalente a:\\
\texttt{a + a * b + a}, \texttt{2 * a + a * b};\\
tenendo conto del fatto che abbiamo un solo sommatore, preferiamo tenere i prodotti, quindi \texttt{2 * a + a * b}.
Le altre due righe non sono ottimizzabili in quest'ottica.

Ora costruiamo il data flow graph

\end{document}

